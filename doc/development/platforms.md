# Platforms #

## Prerequisites for the development: git(hub) user's guide  ##

As a developer, you first have to sign up to [Github](https://github.com/) to be able to contribute to ezPAARSE and:

* write a new parser
* maintain an existing parser
* contribute to improvements in the core of ezPAARSE's code

You then need to know a few [git](http://git-scm.com/) commands:

```bash
#get a local version of the github
git clone https://github.com/ezpaarse-project/ezpaarse.git

#if you already had the project, update it
cd ezpaarse/
git pull

#edit a file
cd ezpaarse/
echo "// my modification" >> ./app.js

#get an overview of which files have been modified/added/deleted (before a commit)
git status

#compare the local modifications with the local repository, line by line, before saving the modifications
git diff

#send the modifications to you local repository
git commit ./app.js -m "a comment explaining my modification""

#display the list of commits
git log

#add a new file
touch ./myexamplefile
git add ./myexamplefile
git commit ./myexamplefile -m "add an example file"

#send the (commmitted) modifications to the distant repository (authorization from the distant repo needed).
git push
```

Note: unless you have a privileged access (from the ezPAARSE team), you must first "fork" the ezPAARSE github repository in order to work on that copy. Once you are satisfied with your changes, you can submit your work to the team by sending a ["pull request"](https://help.github.com/articles/using-pull-requests). Your job will be reviewed and integrated by the team, if no problem is detected. The team then provides write access rights to regular contributors, in order to facilitate contributions.

## How does a parser work? ##

A parser takes the form of an executable `parser.js` file accompanied by a description file [manifest.json](https://github.com/ezpaarse-project/ezpaarse-platforms/blob/master/sd/manifest.json) and a validation structure (contained in the 'test' directory, see below).

This is program, taking as input:
   * the platform's URLs that the parser can analyze (one per line)
   * or a JSON stream (with the --json option) containing
       * the platform's URLs that the parser can analyze (one per line)
       * Other information to qualify the Access Events (such as the size of the download)

The parser outputs a JSON stream containing the recognized access events.

Its usage is documented when you call it with the `--help` option.
An [example parser](https://github.com/ezpaarse-project/ezpaarse-platforms/blob/master/js-parser-skeleton/parser.js) is available.

### Usage Examples ###
```bash
echo "http://www.sciencedirect.com:80/science/bookseries/00652296" | ./parser.js
#{"unitid":"00652296","print_identifier":"0065-2296","title_id":"00652296","rtype":"BOOKSERIE","mime":"MISC"}

echo '{ "url": "http://www.sciencedirect.com:80/science/bookseries/00652296", "status": 200 }' | ./parser.js --json
#{"unitid":"00652296","print_identifier":"0065-2296","title_id":"00652296","rtype":"BOOKSERIE","mime":"MISC"}
```


## Writing a Parser ##

Parsers are written in **Javascript**. A good knowledge of the language is however not necessary to write a parser. Most of the code being outsourced in a common file for all parsers, only the URL analysis function must be adapted, making the code short and relatively simple. Most parsers still require a basic knowledge of **regular expressions**.

Writing a new parser consists of:
* creating the manifest.json file (see below)
* creating the test file, according to what is documented on the plaftform analysis page
* creating the parser so that its output is conform to the test file (see below)
* launch the validation tests (see below)

Once the tests have been validated, the parser can be integrated to the github repo.

A [parser skeleton](https://github.com/ezpaarse-project/ezpaarse-parsers/blob/master/js-parser-skeleton) can be used as a starting point. The folder structure, the files and the skeleton can be automatically generated by launching the [platform-init](/doc/tools.html#platform-init) command.

Tools are available online to [help you visualize the writing of regular expressions](http://www.regexper.com/).

A [detailed procedure](http://analogist.couperin.org/platforms/contribute/parser) is available on AnalogIST

## Testing Parsers

Each parser is accompanied by what it needs to be tested: one or more files in the subdirectory `test` parser package. These files are in CSV format and follow the ``platform.version.csv`` pattern.

The test principle is represented by the following diagram:
![Parsers' test](../_static/images/ezPAARSE-Test-des-Parseurs.png "Test des parseurs")

For each row, column data prefixed by ``in-`` are sent to the parser, and the result is compared with the columns prefixed by ``out-``. These must be strictly identical.

More details on the identifiers returned by parsers are available on [this page](./ ec-attributes.html).

In case the parser takes only an input URL (ie no other fields prefixed by ``in-``), it is possible to manually run the test file with the following command (from the directory the platform):

```bash
#platform.version.csv is the test file
cat test/platform.version.csv | ../../bin/csvextractor --fields="in-url" -c --noheader | ./parser.js
```

The tests are integrated into ezPAARSE's platforms folder.
To launch them, you need to setup the environment first (ezPAARSE doesn't need to be running as the parsers' tests are now autonomous):
```
cd platforms/
make install
```

You can then either test all parsers:
```
make test
```

or test only a selection, by naming them (use the shortnames).
For example, if you want to test the parsers for Nature and ScienceDirect:
```
make test sd npg
```

## Description of a parser

The parser is described by a ``manifest.json`` file, located in the parser directory.
This file contains the following information:

* **name**: the short name of the parser, used as a prefix to the file names. Care should be taken not to use a name already used.
* **version**: the current version of the parser. It is used in the validation file names parsers.
* **longname**: the long name of the parser, used in the documentation.
* **describe**: the description for the parser, can be a paragraph.
* **docurl**: the URL of the documentation on the analogist website (must end by /).
* **domains**: an array of domains that the parser can handle.
* **pkb-domains**: if the platform has a PKB and if domains are present, this field is the column that contains them,
* **recognize**: a table matching each type of consultation (true) to the parser recognition capabilities.

The manifest.json file is used to dynamically display the [characteristics of all parsers](http://analogist.couperin.org/platforms/start#capacites-des-parseurs).


## Vendors' PKBs management principles

Knowledge bases are used to:

* match the identifiers found on publishers platforms (which can be specific and proprietary) and standardized identifiers (like ISSNs)
* include the titles of accessed resources in the results

Knowledge bases are saved as text file [KBART format](http://www.uksg.org/kbart/s1/summary) and are specific to each platform.
The ``platform_AllTitles.txt`` file contains the mappings between identifiers of a specific platform and ISSN (or other standardized identifier). The KBART field called ``title_id`` is used to establish this correspondence with the ``print_identifier`` field (for paper resources) or `online_identifier`` (electronic resources). The [list of KBART fields](http://www.uksg.org/kbart/s5/guidelines/data_field_labels) and their meaning is available.

Knowledge bases are loaded by ezPAARSE and their structure must be previously controlled by the [pkbvalidator tool](/doc/tools.html#pkbvalidator)

[More on AnalogIST](http://analogist.couperin.org/platforms/contribute/parser)

## Running a specific test ##

For testing a specific feature, use mocha and give the path of the test file as a parameter.
For example, to test custom formats:
```console
. ./bin/env
mocha ./test/custom-formats-test
```

For running only one feature test, use mocha and give the path of the test file and the two-digit number (``@xx``) of the test (with ``-g``) as parameters.

For example, running only the second test of personalized formats will look like:
```console
. ./bin/env
mocha ./test/custom-formats-test -g @02
```

To test a single platform, use mocha and give the path of the test file and the platform name (with ``-g``) as parameters.

For example, testing only the ScienceDirect platform will look like:
```console
. ./bin/env
mocha ./test/platforms-test -g sd
```
